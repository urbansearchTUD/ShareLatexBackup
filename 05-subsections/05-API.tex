\section{System API}\label{sec: 5-API}
To provide an easy way of interacting with the back-end of the system we decided to develop a web API. With this API the different parts that compose the complete UrbanSearch system are made easily accessible. During the development of the API we have tried to adhere to best-practices and community standards as described in \cite{apigee}. Appendix \ref{sec: API-appendix} contains a detailed description of the available API routes and their functionality.

\subsection{General Remarks}

All routes in the API start with the "/api/v1" prefix. The routes below will be referred to without this prefix to keep the text concise. The API always returns a 200 status code, the response body also contains a status code which indicates if a request was handled successfully.

\subsection{Flask}
The UrbanSearch back end is written completely in the Python programming language. To be able to accept HTTP requests that leverage the system we needed a framework that works efficient with Python code. For this we chose Flask\footnote{\url{http://flask.pocoo.org/}}, a Python microframework that lets us handle incoming requests making use of the functionalities of the UrbanSearch system.\\
The easy setup and good documentation, combined with the small size and efficiency of Flask made us decide to use Flask as our web framework.

\subsection{Blueprints}
To keep our API modular we use the concept of \texttt{Blueprint}s\footnote{\url{http://flask.pocoo.org/docs/0.12/blueprints/}}. \texttt{Blueprint}s in flask are modules that implement functionality which later can be registered to an application. This way we can keep parts of the API separated and relatively simple. After a \texttt{Blueprint} is initialised routes can be assigned to it. An example of \texttt{Blueprint} is shown in listing \ref{lst:blueprint}.\\

\begin{lstlisting}[language=python, caption={Example code of a Blueprint used in the UrbanSearch system}, label={lst:blueprint}]
predict_api = Blueprint('predict_api', __name__)
ct = ClassifyText()


@predict_api.route('/', methods=['POST'], strict_slashes=False)
@predict_api.route('/predict', methods=['POST'], strict_slashes=False)
@is_json
def predict():
    """
    API route for predicting the category of the supplied text.
    The request should have type set to application/json and the provided JSON
    should have a text attribute containing the text for which we want to
    predict the category.
    """
    try:
        prediction = ct.predict(request.json['document'])

        return jsonify(category=str(prediction[0]),
                       status=200)
    except Exception as e:
        return jsonify(error=True,
                       status=500,
                       message='Getting the prediction failed')
\end{lstlisting}