\section{Storing the Data}\label{sec: 5-storing}
In this section, we discuss how the filtered documents are stored and how Neo4j was used for storing extracted relations, following the design described in section \ref{sec:storage-design}. We discuss the storage and graph database parts from the overview (see figure \ref{fig:overview}).

\subsection{Storing Filtered Documents}
The documents that pass the filtering stage can be stored for several reasons. For example, the classifier can be retrained and might thus label documents differently. To avoid having to download and process all the pages again, it is useful to store the documents on disk. If the disk is small, it is wise to compress the documents. However, compression is a slow process, so if enough disk space is available, storing the documents uncompressed is more feasible.

In the \texttt{TextDownloader} class, that was already shortly discussed in section \ref{sec:5-downloading}, storage to disk is done without compression in all cases. 
\subsection{Storing Extracted Relations}
% steden op basis van lijst van klant, coordinaten opgezocht via google api
% issue: steden met dubbele naam kregen zelfde coordinaten en niet per se de grootste, maar belangrijkste (volgens google)
% neo4j city node
% neo4j index node
% occurrence relation
% intercity relation
% parameterised optimisation -> benchmark
% bulk vs single -> single transaction instead of transaction for every statement, benchmark
% transactional vs multithreaded -> data inconsistencies
% neo4j python driver issues
% solution: use neo4j's own multi-threading using UNWIND -> embedded multithreading
% remarks: 
% try SQL instead of NoSQL to compare results
% perhaps java instead of python driver to be able to use multithreading
\todo{mention multithreading neo4j (embedded)}