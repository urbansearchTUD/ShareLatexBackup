\section{Conclusion}
In this report, we explored the problem domain to be able to define and analyse the problem. Doing so, the product requirements were extracted in order to prepare for an attempt to solve the problem.

First, we discussed related work. We saw that there are many methods that try to estimate the flows between cities. However, all of these approaches turned out to be either very limited or questionable. Some other approaches that use digital content for estimating these relations looked promising but are small scale. Web data contains many relations that were overlooked by methods. An example is the method where researchers looked at the different locations where businesses are located. \\

We saw that there are currently two methods for analysing the relations between cities. Manually analysing search engine data is very slow and requires a lot of man-hours and looking at the different locations where businesses are located is only interesting for the economic relation and still misses a lot of data.
\\

Second, we identified the requirements for a solution to the problem and discuss issues that might arise. The used the MoSCoW model to describe the importance of the different requirements. The most important must haves we found are being able to input place names, displaying a map with the connection data and being able to extract this data.
\\

Third, we described a framework that satisfies the requirements and tackles the issues. We decided to start by using data from Common Crawl, although we might later extend this to other data sources such as Delpher. After selecting relevant data (data which contains 2 or more city names) we store the data with Neo4j. We then use a classifier to group the data. We use this on all data to extract categories and process these per pair of cities to see what the important connection types for each city are. To visualise this data we use the graph Neo4j provides.
\\

Finally, we discussed how to verify and validate the (intermediary) results from the system. The code is tested using four common types of testing: unit testing, integration testing, system testing and acceptance testing. All types serve a different purpose and together should indicate how well the system performs. Additionally, the code is sent to the Software Improvement Group for quality analysis.
\\

With this setup we should be able to make a well tested, functioning system that meets the requirements of our clients. Furthermore, using this system will enable us to answer the question "how can the strength of relationships between cities be extracted and visualised from open data?" 